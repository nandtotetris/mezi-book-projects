# title
A Computer Visualizer, from OS to NAND gates

# members
1.	Mezigebu Zework ... ¬¬ATR/0337/08
2.	Henok Tesfaye     … ATR/2487/08
3.	Biruk Misganaw   … ATR/2038/08
4.	Michale Rezene    … ATR/5760/08
5.	Tewodros Meselu … ATR/2140/08

# advisor
Mr. Abebe Assefa

# acknowledgment 
We would like to thank Noam and Shimon for writing the wonderful book ‘The elements of computing systems, building a modern computer from first principles’. The book has inspired and emboldened us to choose the project title which this proposal attempts to expound and defend.

# abstract
In this proposal we are going to introduce a project inspired by the book: The elements of computing systems, building a modern computer from first principles by Noam Nisan and Shimon Schocken. This book comes with a set of tools (developed in java) that allow a student to go through the exciting process of building a general purpose modern computer starting with nothing but elementary NAND logic gates.

This project, among other things, hopes to bring these tools into a more accessible, dynamic, and vibrant medium by replicating and customizing them with JavaScript, so they can be accessed anywhere, right from our browsers. In other words, when this project comes to completion, the user of the application will be able to go through the experience of building a computer from elementary NAND gates, needing only a browser to access all the simulation, testing, and coding tools he will be using in the process. The user will also, through a series of well-defined interactive animations and displays that run on top of this simple and elegant computer, get a taste and an appreciation of the grand and comprehensive picture of what a modern general purpose computer consists of (its salient components), and what kind of interactions (the essential hardware and software abstractions) hold its pieces together.

This project, we believe, is important because it promises, or at least hints, a huge potential for future research related to the process of understanding how a computer works and also, and more heavily so, it holds a potential to lay a foundation work for development of a new and an inclusive approach towards computer and digital electronics manufacturing.

As it is today, the nitty gritty details that are involved in manufacturing a digital electronic device like a computer are fully known to, and are held as secret, by a handful of powerful companies. It doesn't however have to stay this way. Software has already made the leap; many great software tools today are at least partially open source and are made freely available for inspection, development, and expansion by any interested party, be it an individual or a company.

This project can also be seen as a step towards open sourcing the process of manufacturing a computer, or any digital electronic device for that matter. With the open sourcing of such essential tools, and especially with their coming to the browser stage, and with their getting backed by a vibrant community of web developers, it will not be too farfetched to talk of developers, in the near future or even soon, being able to collaboratively design, simulate, test and manufacture digital electronic devices all from the comfort of their home, without having to come together under the same physical building.

There is also a point that makes a project like this very much relevant to students in developing countries, especially to those students that show interest towards playing a part in the process of designing and building digital electronic appliances of all kinds, including a computer. These students, as it is now, undergo only theoretical training, and do not have access to well organized laboratories. An opportunity of getting their hands dirty by interning, or visiting, at real industries is almost unavailable, simply because there are almost no such industries, at least currently, in most of these countries. It is our aspiration that this project, as it matures, will contribute to the creation of virtual laboratories and collaboration hubs that students from developing countries can easily access and take advantage of, as long as they own a browser equipped computer that is connected to the internet.
 
# background 
Computer science and software engineering curriculums, in their current form, are not deliberately connected and well organized to provide students with a clear and comprehensive understanding of what a computer really is, and what essential abstractions combine to endow it with its many sophisticated capabilities. Some courses are cluttered with too much detail, while others scratch only the surface. There is also no clear progression from one course to the next. Because of this, computer science and software engineering students do now graduate without forming a coherent picture of what the essential components of a computer are, what kinds of interactions take place among these components, and what underlying principles and abstractions make these interactions possible. This project aspires to be a step in the direction of gluing together, into a memorable pattern, many of the courses that one way or another touch upon some aspect of a computer; courses that are now too dispersed, and too disconnected, for the average student to be able to form an immediately accessible and a big picture understanding of what a modern general purpose computer is all about.

This project aims to build an application that can interactively illustrate the salient interconnections and abstractions which a high level instruction gets channeled through as it gets turned into a machine code and as it, in the form of a digital signal, floods a hardware architecture made up of just NAND gates, and finally as it turns back up the hierarchy to output devices to produce some perceivable effect. The interactive animations and illustrations will be built on top of a simplified virtual computer, as prescribed in the book 'The elements of computing systems from first principles'. This virtual computer will be running alongside the visual animations and displays.

Anyone who can benefit from a comprehensive understanding of the inner workings of a general purpose computer can be a customer of this application. Particularly, undergraduate students majoring in Information Technology, Software Engineering, or Computer Science will gain immensely from an application like this, since success in these fields one way or another requires a deeper understanding of the principles of a computer.

The good news about this project is that, resource wise, it requires only a computer and an internet connection; it is thus a purely software undertaking. All the tools that will be used in development are open source and freely available, hence there will be incurred no financial cost. Talking of time, the project might take roughly 6 months to implement and bring into a state of some use. It should be noted also that this is a purely non-organizational project motivated solely by our own fascination and curiosity towards understanding a modern general purpose computer.

This project can serve as a foundation, a stepping stone, or a playground, for any project that wishes to experiment with and build upon our minimal, transparent and easily accessible virtual computer architecture. For instance, one can, using the components that will be developed at the core of this application, envision and realize a platform for collaboratively simulating the designing and testing phases of certain digital electronic devices. Anyone who wishes to extend the functionality of our basic computer by adding a desired feature of his own choosing (for example one can add an internet feature by implementing the relevant communication protocols and other related networking details) is free to do so.

This project heavily draws from the Nand2Tetris tools and resources prepared by Noam and Shimon (and their team) as a companion for their book 'The elements of computing systems, building a modern computer from first principles'.

# The Existing System
We have scoured the web trying to find a free software tool that allows for an unrestricted and completely transparent exploration of all the major components and abstractions of a modern general purpose computer, but we couldn't find any that satisfied our curiosity. The ones we found felt only like running some program on a computer, and lacked the generality and comprehensiveness to give their users the full picture of what a computer system consists of. Mix-emulator is the only web application that came closest to what this project intends to achieve. It (http://www.mix-emulator.org) is a web based emulator that emulates, as described in its website, a mythical computer invented by Donald Knuth for his book series: The art of computer programming. There are many deficiencies to this emulator, however. The emulator provides a code editor that accepts what looks like a virtual machine code. After the code is assembled, the user is presented with a table of registers, RAM, and instruction memory. As the program is run, a line at a time, the emulator updates, accordingly, the register and memory entries. Devices can also be attached, and their contents can be probed as the program is executed. The user can step the execution either in the forward or backward direction. That is all. It is hard to imagine users learning about the big picture of what a computer is by just staring at memory contents. The user rather needs to be taken through the entire process, one at a time. The tour (interaction) needs to start with a modern high level language, and should go all the way down to the hardware design, and should come back up to the process that manipulates output devices. Through the journey, important software abstractions such as the compiler (which turns a high level language into a virtual machine code), the virtual machine translator (which translates a virtual machine code into an assembly code), and the assembler (that writes assembly into a machine code) need to be explored. 

Interactions with the operating system, the virtual machine, the CPU, the ALU, the RAM, the registers, even the NAND gates and flip flops need to be shown. Realistic depictions of the contracts and protocols which the operating system uses to communicate with input and output devices (if it is, for example, a memory-mapped interaction) need to be shown in a clear and understandable manner. The emulator lacks all these features.

When it comes to understanding a program’s execution flow (just one aspect which this application will explore, the other aspect being the unboxing of all the essential components of a computer), there do exist several debugging and inspection tools out there that allow users to step through and track a program's state transition through a series of intertwined subroutine calls. These tools, to begin with, focus on understanding a program’s execution flow up to a certain level, and are not interested in creating a comprehensive and an overall understanding of how a computer system works, and how its various components are held together. Education wise, there are obvious reasons that make our application more preferable when contrasted with such existing debugging and inspection tools. It is preferable mainly because our virtual computer and the abstractions that ran on top of it (the assembler, the VM translator, and the compiler) are all simple enough to control and understand (as will later be elaborated in the proposed system and the scope section of this document). Because of this simplicity, the user will not be confused in trying to assemble details that are just too many to digest. Also, since we have full control of all abstractions, we can show the user every essential layer; including the HDL code, the assembler code, the VM translator code and the compiler code, and every related interaction that takes place to make the program operations possible. Such transparency, control, and simplicity is an advantage we have, which other tools cannot boast because of the sheer complexity of the underlying system they have to deal with, and because they simply don't have access to everything. The authors of these debugging and inspection tools did not build the underlying computer system themselves, from scratch; they are, as it is, boxed out of important abstractions (such as the hardware design, the assembler, the VM translator, and the compiler), and hence cannot reveal every necessary detail, all the way down to the level of NAND gates, in a satisfactory manner.

# Statement of the Problem 
As Noam and Shimon stated in the preface of their book (The elements of computing systems) the problem is software engineering students are losing the forest for the trees. They are prevented from appreciating the big picture at large because they are too occupied with overly specialized and widely distributed courses, and are hence unable to make the necessary connections that would have allowed them to gain a greater insight. There exists now neither a course nor a unified set of tools that is tailored and adapted towards creating a clear, comprehensive and coherent understanding of a simplified general purpose computer. Lacking a gestalt understanding of computer systems is a prevalent and pervasive problem suffered by computer students, teachers, hobbyists, and technicians alike. 

Vast amount of energy and resource is continually being wasted because of a deficient and mediocre understanding of computers. Many of the systems that run on computers today are inefficient and error prone because they were built with inadequate understanding of the underlying system. Many software systems are going obsolete because no one understands what is wrong with these systems, and how they are interacting with the underlying computer architecture. Computers are now manufactured only by few monopoly companies, and few countries host these monopolies. Other companies, and countries, are shying away from producing computers because they assume the undertaking as an overly complex enterprise; computers are perceived as too sophisticated to understand, let alone to design and manufacture. This exaggerated fear of venturing into the inner workings of computers has made it easier for few elite companies to control the computer market, and thereby to set a price of their wish. The toll ultimately falls on each and every one of us; we are forced to pay inflated prices for products we do not, and cannot (since they are black boxed), understand. To make their computers more efficient and robust, companies keep incorporating into them a pile of mysteries and tricks, details they do not reveal to us so we would never come to understand and replicate them . What is more dismaying is even countries, as nations, are losing hope of ever joining the enterprise of making affordable computers. Many students and professionals simply don't know what to do with their computers, because they do not understand them. When computers malfunction, only few dare to understand the cause and almost none tries to fix. Computers are powerful machines, but are sitting idle everywhere; being used only for mundane chores, such as word processing and photo editing. Everyone and everything, from individuals to countries, and from the economy to politics, suffers from this epidemic of illiteracy induced inefficiency.

Everyone can not of course understand everything about computers. But at least those who build their trade and livelihoods around computers should have some decent understanding. Our solution focuses on students, instructors, hobbyists, and professionals who are willing to undertake a serious training on computers, and who thereafter wish to embark on the exciting journey of developing themselves either some software or hardware component of computers, or some system that works on, or with, computers. Our proposed solution involves developing an application that interactively animates a program's execution flow starting from some high level instruction and proceeding all the way down to a sequence of NAND gates. The application will help the user unbox and unravel all the main abstractions that a program's execution flows through as it is turned into some output, or effect, which the user ultimately perceives/feels.

The application will, at its core, have an elegant and simple virtual computer fitted with all the crucial components and features of a general purpose computer, but with its components adapted to their simpler and easier to understand versions; all however without losing their illustrative capacity. The interactive animations and displays will all be built by inspecting, exploring, and unmasking the details of this virtual computer. This advantage (of simplicity and control we have) will allow the user to get not a bits and pieces understanding of a computer, but an over all, comprehensive and coherent understanding that cannot easily be found anywhere else.

# Objective of the Project
- # General Objective
The application is expected to be a hub where computer students come to piece together several software and hardware abstractions of a computer that they have gleaned, in fragmented forms, from several computer science courses. It is where they will solve the jigsaw puzzle of a computer's software and hardware architecture to unravel the big picture of what a general purpose computer really is, and what components and abstractions it encompasses. Users, having comprehended the essential details of a general purpose computer through this system, will potentially be able to gain an understanding of any digital system and will even be empowered enough to build a system of their own.
- # Specific Objective
Specifically, computer enthusiasts and students, through the application, will be able to track a program's execution flow all the way from input devices down to a series of NAND gates, and back up to output devices. Along the way, they will explore several abstractions, mechanisms, and interactions that make possible the various operations that take place at each step of the execution flow. They will be able to do so in an easy to follow, and visually appealing, sequence of interactive animations that tap into an emulation of a running virtual computer.

# Proposed System
At the threshold of the solution lies the task of designing and constructing a simple and elegant conglomeration of some hardware architecture and a couple of software abstractions. This step is necessary to first realize the simple and elegant general purpose computer that will be the heart and engine of the final application. 

The implementation of the hardware architecture will start from primitive NAND gates, and flip flops, and will hierarchically build all the essential hardware components (including registers, RAM, program counter, ALU, Keyboard, Screen, and CPU) till finally the hardware implementation of some general purpose computer is achieved. The designing of the hardware components will be done with a hardware description language (HDL). In order to test the functionality of the hardware components, and ultimately in order to run some code (a series of zeros and ones) on the hardware, the application will integrate a hardware simulator (emulator) that wraps around, probes, and interacts with the underlying hardware architecture. The hardware simulator will be able to do so by internally modelling the attributes and behaviors of all the hardware components (components parsed or mimicked from their respective HDL designs), and by assembling these models as specified by the HDL design of the overall hardware architecture. 

The software architecture will consist several layers; including an assembler, a virtual machine translator, a compiler, and an operating system. All these layers, except the operating system, will be written with typescript (a typed flavor of JavaScript). In order for these layers to be meaningful there will have to be defined an assembly language for the assembler to work with, a virtual machine architecture and language for the virtual machine translator to deal with, and a high level language for the compiler to operate with and for the operating system to be written with. At the top of the system will have to sit an inspector that incorporates, underneath its smooth skin, all the aforementioned software layers, and an animator that will animate and display outputs generated by the inspector. The inspector will receive all the interactive commands and instructions from the user, and will forward these commands down the chain of software and hardware abstractions (by initiating respective software components, and by triggering the hardware simulator accordingly), and will invoke the animator to display and animate all the features and concepts that it explores at each step of the way. As such, the user will be able to learn all the key aspects of a general purpose computer all in one place, without ever losing sight of the picture at large. A summary of the underlying modern general purpose computer upon which the proposed system will be founded on is shown in the picture below.
 
[Figure 1.1 Hardware and Software Architecture]

# Feasibility Study
- # Economic Feasibility
    - # Developmental cost 
    The system incurs almost no financial cost for its development. The only purchasable resources that will be needed are a computer and an internet connection. So it can be confidently said that the project has no significant development cost.

    - # Operational Cost 
    All that will be required to operate the system is a browser equipped computer. Therefore, the project will introduce no tangible operational cost.

- # Technical Feasibility 
The project is technically feasible because all its components are already well known, and precisely defined. The system will not introduce a radically new component (be it a hardware or a software component), it will simply reduce the complexity and increase the control of the already existing components (of the computer systems we use today) by modifying and adapting them in a managed and incremental approach. A software realization of the inspection and simulation of these components is also not something unattainable. There are several simulation and inspection software tools in the market to prove the feasibility of running inspection and simulation on top of an intricate system that is composed of several interconnected models.

- # Schedule Feasibility 
Implementing all the hardware and software abstractions will require at least two months. The contracts (APIs) for these components are clearly defined in the book 'The elements of computing systems, building a modern computer from first principles' by Noam and Shimon. An additional three months should suffice to integrate these components, to build the hardware simulator, and to attach on top the inspector, and the animator. So, all in all, we expect the first and trial version of the system to be functional and ready after five months of development work. This time may not suffice to include all scenarios with which a user might like to inspect and explore a computer system, but it should be enough time to demonstrate a few of these illustrative and interactive scenarios.

# Scope
The virtual computer that will be serving as the core component of the system, as reiterated several times before, will deliberately be made simple and elegant. It will showcase limited, but essential, features and components only. It cannot be expected to have all the features and services provided by a full-fledged general purpose computer. 
The hardware will support 16 bit words only. The RAM will be just 32 kilobytes. The ALU will support a limited number of mathematical and logical operations; such as add, subtract, and, or, negate, invert, less than, greater than, and equal. Division and multiplication will not be implemented in hardware, but in software. The virtual computer will allow mathematical operations only on integers; rational numbers will not be supported. The CPU will have only two registers, which suffice to perform its limited number of logical and mathematical operations. Among peripheral devices, only a keyboard and a screen will be implemented. Common peripheral devices such as mouse will not be part of the hardware architecture. The hardware design will not feature an internal or external hard drive, cache memory, an internet card, a graphics card, an audio port, a mic port, or any USB port.

The software architecture will provide an operating system that hosts a modest number of services. Advanced operating system services such as file system, scheduling, multi-threading, graphical user interface, user accounts, security features, internet services, and other communication protocols, etc. will not be supported. The operating system will be composed of few basic modules that will expose necessary APIs for mathematical operations, string manipulation, keyboard and screen interaction, basic memory management, array manipulation, and few system operations (such as running the main program, reporting errors, and halting programs). The operating system can run only a single program at a time. Dynamic loading of a program’s code is not supported. The program code will have to be written and ready before the operating system boots. There is only one screen through which the user can enter inputs, and view graphical as well as string outputs. The high level language that will be supported by the operating system will not have advanced object oriented features; such as inheritance, interfaces, and inner classes. It will however support classes, methods, and normal functions.

All the interactive animations and displays that will be explored by the inspector and the animator will be customized according to the limitations of the underlying virtual computer implementation. The limitations are deliberate; they are necessary in order to achieve a level of simplicity and control that will allow for the illustration of only the essential components and abstractions of a general purpose computer system, without bombarding the user with an endless stream of minute and confusing details. The inspector, in addition to exploring supported features and components, will also unravel the control system and the glues that make these abstractions work together (including the assembler, the virtual machine translator, the compiler and the operating system codes).

# Methodology 
As its documentation and planning methodology which will be used for collecting requirements and preparing various formal documents, this project will stick to waterfall methodology. But for development we will be using agile methodology. The waterfall steps will help us stay focused on our bigger objectives. The documents we will be producing by following the waterfall methodology will allow us to not lose sight of the ultimate picture of what we will be building. They will help us stay on the right track. Whereas the agile methodology we will follow for development will enable us to move in a productive, efficient and flexible manner. As more is learned and understood about the realistic situation of the system (through the agile development approach), we will reflect the changes, and accordingly add necessary modifications, to the documents we will have prepared under the schedules of the waterfall methodology.  So when the system will be completed, by looking at the final versions of the project's documentation one will get the feeling as if everything was done by conforming to waterfall development stages. And through these organized documentations, one can learn all there will be to know about the system's architecture and development details.

As stressed above, for a development methodology of the project, we would like to go with agile, and specifically scrum. We chose so because waterfall, spiral, and other models focus too much on planning and documentation, while agile focuses on delivering a working software as soon, and as frequently, as possible. We are going to keep our development approach simple and straightforward. In scrum there is what is called a backlog. The backlog is simply a changing and growing list of functional and nonfunctional requirements, and features that we would like our system to satisfy. Then there is the concept of a sprint. A sprint is a task that needs to be delivered within a period of few days, or a week. A sprint is constructed by selecting priority tasks from the backlog (the main list). So there will be new sprints every week till the backlog is empty. Whenever a new requirement is discovered, or when a new feature needs to be added, or when a bug needs fixing, it will be inserted into the backlog. Planning, designing, and discussion will be held at all times as demanded by the needs of each sprint. This methodology is very clear and simple to follow, and will help the team to immediately get started with relevant and fruitful work. The team, as a result, will not waste valuable energy and motivation because it will not be bogged down, and lost, in the bureaucracy of planning and documenting everything before actually doing something worth showing. The team will be more encouraged, and efficient, if it is made to work this way since it can see progress by starting small and by adding features and functionalities incrementally, getting enough satisfaction at each step of the way. When the work requires separation of tasks in different modules, integrations will be made continually without waiting for each module to bloat and grow into unmanageable complexity.

Ideally, we may have the following columns in our project management software (which can be Jira):  ‘new issues’, ‘icebox’, ‘backlog’, ‘in progress’, ‘needs review’ and finally ‘ready to be deployed’. 
- # New issues 
This is a column where we introduce new issues that need to be addressed. For instance, if one of the deployed features in the past week caused some problem, we immediately create a new issue and we prioritize and move it to the backlog depending on how urgently the issue needs fixing. 
- # Icebox
This is the place where we enter all the system’s features and ideas at the project start as well as throughout the project. This means that any new story goes to the icebox first. The story can be promoted into a system feature, or issue, and can be moved to a new issue or backlog for that matter if the description is found to be technically convincing. 
- # Backlog 
This is where we put tasks that should be accomplished within a certain period of time. The features/issues in this column are ordered according to their priority levels. The most urgent tasks will be put on top with a ‘high priority’ or ‘urgent’ label. 
- # In Progress 
This column is pretty straight forward; we simply put the features we are currently working on here, so that all the team members will get to know the feature that is in progress and hence only a single person works on a given feature at a time.
- # Needs Review
Once a feature is developed, it doesn’t get to be deployed right away; other team members need to give it a rigorous testing. This reduces the bug rate we will have in our project. Some features may require more testing than others. In the case of high risk features (features that have the potential to break the system), more than one team member should test the feature. If the feature is not good enough it will be tagged with an issue ticket and will be sent back to the ‘In Progress’ column.
- # Ready to Deploy
This is a column where we put features (pull requests, in git language) that have been reviewed and tested well and approved by at least one team member. Soon enough, the feature gets merged and becomes part of the system.
The columns are illustrated and clearly shown in the example image given below.
 
[Figure 1.2 Scrum board on Jira software]

# Project Management plan  
- # Time Management plan
The following time management plan (Gantt chart) will guide the preparations, researches, and documentations that will be done in accordance with the waterfall methodology.
 
[Figure 1.3 Waterfall time management plan]

- # Quality Management Plan
Among the many factors that might hinder the ultimate quality of this system, a growing list of unattended logical errors and coding bugs will most likely stand out as top priority. If a close watch is not maintained over this factor, little bugs and errors all over the place would soon infest the system and render it unusable before it sees completion. In order to prevent such undesirable misfortunes from befalling the project, every implemented component and abstraction need to undergo a rigorous testing, first separately (through unit testing), and second upon integration with other components (through integration testing). Whenever a change is made to a component, all relevant tests need to be revised and rerun.
Another source for quality impediment would be lack of clarity, simplicity, appeal and robustness in the interactive animations and displays through which the user will explore the inner workings of the modern general purpose computer (the heart and the engine of the system). To minimize the possible quality degradation that will be inflicted due to this factor, all implemented interactions and animations will have to be shown to potential users, and received comments and suggestions will have to be enforced before the feature is approved as done and settled.

- # Communication Management Plan
In this project, there are no external stakeholders, other than potential customers and the project’s advisor, with whom the development team will have to communicate. Internal communications will be of four types. Formal code sharing and merging will be done over git. Formalized scrum tasks list (backlog), issues, sprints, and related communications will be done using Jira. Formal documentation sharing and communication will be done through google docs. Informal discussions and communications will be done via a dedicated telegram group. All of the internal communications will be held among the project team, whereas the external communications will be done with the project’s advisor.
The following table summarizes the communication management plan of the project.

[Table 1.1 Communication management plan]

# REFERENCE
https://www.nand2tetris.org 
https://acodez.in/12-best-software-development-methodologies-pros-cons/
https://www.codeproject.com/Articles/604417/Agile-software-development-methodologies-and-how-t
http://www.mix-emulator.org/#/about

