# Title
- ##### Computer visualizer, from OS to NAND gates
- ##### Program flow analyzer, from OS to NAND gates
- ##### Program flow emulator, from a high level instruction up to a NAND gate

# Background

  Computer science and software engineering courses are, as given now, not well structured to provide students with a clear and comprhensive understanding of what a computer really is, and what essential concepts/theories it entails. Some courses are cluttered with too much detail, while others scratch only the surface. And there is no clear progression from one course to the next. Hence computer science and software engineering students often graduate without forming a lucid picture of the components that make up a computer, the interactions that take place between these components, and the underlying principles and abstractions that in turn make the interactions possible.

  In this project, we aim to build a web app that visually and interactively illustrates the salient interactions and abstractions that a high level program (operation) passes through till it is turned into a machine code (of zeros and ones) that is channeled through an architecture made up of just nand gates and flip-flops. The interactive animation will be built on top of a simplifed virtual computer (as specified in the book 'The elements of computing systems from first principles') that will be running alongside the visual animations and displays.

  With the guidance of the aforemntioned book, we have already built and tested all the components of the virtual computer, starting form its hardware design (written in HDL) all the way to its simplistic OS (written in the simple high level language Jack). The abstractions we built include an assembler, a virtual machine translator, and a compiler. 

  For example, consider a simple program that reads two integers from the user and outputs their sum. How does the computer know to read and interpret user inputs, with what protocol does it communicate with the keyboard? How then does it turn the inputs into integers, and perform mathematical operations on them? Finally, how does it know to correctly display the output on the screen? Our application hopes to demystify the chain of events that make such simple (and taken for granted) operations possible. Our application will feel like following the electric signal emitted by simple key strokes through all the phsyical and software components it passes through, till it is finally turned into a sensible screen output. All the black boxes, and abstractions therein, will be unboxed and made clear through a series of easy to understand, and visually appealing, animated displays.
  
  Our application is preferable, as compared to existing debugging and inspection tools, because our virtual computer and the abstractions that ran on top of it (the assembler, the vm translator, and the compiler) are all simple enough to control and understand (we know that because we were able to build them in the span of two months). Because of this simplicity, the user will not be confused with too much detail, and because we have control of all the abstractions, we can show the user everything (including the hdl code, assembler code, the vm translator code and the compiler code) and every interaction that takes place to make the program operations possible. Such transparency, control, and simplicity is an advantage we have, something which other tools can not boast about because of the sheer complexity of the system they have to deal with, and because they simply don't have access to everything (they are boxed out of important abstractions, such as the hardware design, the assembler, the vm translator, and the compiler).